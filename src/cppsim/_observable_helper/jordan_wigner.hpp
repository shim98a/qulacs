#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <complex>
#include <limits>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <utility>
#include <vector>

#include "pauli_terms.hpp"


namespace observable_helper {


namespace helper_internal {
 
constexpr pauli_id_type PauliX = 0b01;  // 1 for 'X'
constexpr pauli_id_type PauliY = 0b10;  // 2 for 'Y'
constexpr pauli_id_type PauliZ = 0b11;  // 3 for 'Z'


// shift `pauli_id` (2bits) to most significant bits in a `single_pauli_type` variable
inline single_pauli_type shift_pauli_id_to_MSB(pauli_id_type pauli_id) noexcept {
    return static_cast<single_pauli_type>(pauli_id) << (sizeof(single_pauli_type) * 8 - 2);
}

// embed `PauliX` (2bits) in the two most significant bits of `index`.
inline single_pauli_type to_pauli_X(index_type index) noexcept {
    return index | shift_pauli_id_to_MSB(PauliX);
}

// embed `PauliY` (2bits) in the two most significant bits of `index`.
inline single_pauli_type to_pauli_Y(index_type index) noexcept {
    return index | shift_pauli_id_to_MSB(PauliY);
}

// embed `PauliZ` (2bits) in the two most significant bits of `index`.
inline single_pauli_type to_pauli_Z(index_type index) noexcept {
    return index | shift_pauli_id_to_MSB(PauliZ);
}

// embed `pauli_id` (2bits) in the two most significant bits of `index`.
inline single_pauli_type to_pauli(index_type index, pauli_id_type pauli_id) noexcept {
    return index | shift_pauli_id_to_MSB(pauli_id);
}

// `index_mask = 0b0011...11` (two leading zeros and trailing ones).
constexpr single_pauli_type index_mask = std::numeric_limits<single_pauli_type>::max() >> 2;

inline float_type get_real(float_type x) noexcept { return x; }

inline float_type get_real(const std::complex<float_type>& x) { return x.real(); }

inline float_type get_imag([[maybe_unused]] float_type x) noexcept { return 0.0; }

inline float_type get_imag(const std::complex<float_type>& x) { return x.imag(); }

inline float_type get_conj(float_type x) noexcept { return x; }

inline std::complex<float_type> get_conj(const std::complex<float_type>& x) { return std::conj(x); }

// This is used in `jordan_wigner_two_body_3_cites` and `jordan_wigner_one_body`.
constexpr std::pair<pauli_id_type, pauli_id_type>
XX_YY_YX_XY[4] = {
    {PauliX, PauliX}, {PauliY, PauliY}, {PauliY, PauliX}, {PauliX, PauliY}
};

// Assumes `p <= q`
template<typename Coeff>
void jordan_wigner_one_body(
    index_type p, index_type q, Coeff coefficient, HermitianPauliTerms& terms
) {
    if(std::abs(coefficient) < eq_tolerance) {
        return;
    }

    if(p != q) [[likely]] {
        // off diagonal part

        // paulis = Pp Zp+1 ... Zq-1 Pq
        std::vector<single_pauli_type> paulis(q - p + 1);
        size_t idx_in_paulis = 1;
        for(index_type i = p + 1; i < q; i++) {
            paulis[idx_in_paulis++] = to_pauli_Z(i);
        }

        float_type coeffs[4] = {
            0.5 * get_real(coefficient),
            0.5 * get_real(coefficient),
            0.5 * get_imag(coefficient),
            -0.5 * get_imag(coefficient)
        };

        for(size_t i = 0; i < 4; i++) {
            paulis[0] = to_pauli(p, XX_YY_YX_XY[i].first);
            paulis[q - p] = to_pauli(q, XX_YY_YX_XY[i].second);
            terms.add_term(paulis, coeffs[i]);
        }
    } else {
        // diagonal part
        terms.add_constant(0.5 * get_real(coefficient));
        terms.add_term(
            std::vector<single_pauli_type>{to_pauli_Z(p)},
            -0.5 * get_real(coefficient)
        );
    }
}

// Assumes `p < q`
template<typename Coeff>
void jordan_wigner_two_body_2_cites (
    index_type p, index_type q, Coeff coefficient, HermitianPauliTerms& terms
) {
    if(std::abs(coefficient) < eq_tolerance) {
        return;
    }

    float_type coeff = 0.25 * get_real(coefficient);

    terms.add_constant(-coeff);
    terms.add_term(std::vector<single_pauli_type>{to_pauli_Z(p)}, coeff);
    terms.add_term(std::vector<single_pauli_type>{to_pauli_Z(q)}, coeff);
    terms.add_term(std::vector<single_pauli_type>{to_pauli_Z(p), to_pauli_Z(q)}, -coeff);
}

/**
 * Assumes `(p,q,r,s)` is generated by the C++ version of the Python generator
 * `itertools.combinations(itertools.combinations(range(n_qubits), 2)`,
 * where `n_qubits` is the number of qubits.
 * Also, `set(len([p, q, r, s])) = 3` is assumed in this function.
 * So in this function we can assume that
 *  - `p < q`
 *  - `r < s`
 *  - `p < s`
 *  - `if p == r, then q < s`
 *  - `if q == r, then p < s`
 *  - `if q == s, then p < r`
 */
template<typename Coeff>
void jordan_wigner_two_body_3_cites (
    index_type p, index_type q, index_type r, index_type s,
    Coeff coefficient, HermitianPauliTerms& terms
) {

    if(std::abs(coefficient) < eq_tolerance) {
        return;
    }

    index_type a = 0, b = 0, c = 0;

    // paulis_to_add_1 = Zc * paulis_to_add_2, where
    // paulis_to_add_2 = Pa Za+1 ... Zb-1 Pb (b-a+1 paulis)
    std::vector<single_pauli_type> paulis_to_add_1;
    size_t idx_a_in_paulis_1, idx_b_in_paulis_1;

    if(p == r) {
        a = q; b = s, c = p;
        coefficient *= -0.25;
        // c < a < b.
        // paulis_to_add_1 = Zc Pa Za+1 ... Zb-1 Pb (b-a+2 paulis)
        size_t n_paulis_1 = b - a + 2;
        paulis_to_add_1.resize(n_paulis_1);

        paulis_to_add_1[0] = to_pauli_Z(c);
        size_t idx_in_paulis = 2;
        for(index_type i = a + 1; i < b; i++) {
            paulis_to_add_1[idx_in_paulis++] = to_pauli_Z(i);
        }

        idx_a_in_paulis_1 = 1;
        idx_b_in_paulis_1 = n_paulis_1 - 1;
    } else if(q == r) {
        // a, b, c = p, s, q;
        a = p; b = s; c = q;
        coefficient *= 0.25;
        // a < c < b
        // paulis_to_add_1 = Pa Za+1 ... Zc-1 Zc+1 ... Zb-1 Pb (b-a paulis)
        size_t n_paulis_1 = b - a;
        paulis_to_add_1.resize(n_paulis_1);

        size_t idx_in_paulis = 1;
        for(index_type i = a + 1; i < c; i++) {
            paulis_to_add_1[idx_in_paulis++] = to_pauli_Z(i);
        }
        // skip Zc
        for(index_type i = c + 1; i < b; i++) {
            paulis_to_add_1[idx_in_paulis++] = to_pauli_Z(i);
        }

        idx_a_in_paulis_1 = 0;
        idx_b_in_paulis_1 = n_paulis_1 - 1;

    } else if(q == s) {
        // a, b, c = p, r, q;
        a = p; b = r; c = q;
        coefficient *= -0.25;
        // a < b < c
        // paulis_to_add_1 = Pa Za+1 ... Zb-1 Pb Zc (b-a+2 paulis)
        size_t n_paulis_1 = b - a + 2;
        paulis_to_add_1.resize(n_paulis_1);

        size_t idx_in_paulis = 1;
        for(index_type i = a + 1; i < b; i++) {
            paulis_to_add_1[idx_in_paulis++] = to_pauli_Z(i);
        }
        paulis_to_add_1[n_paulis_1 - 1] = to_pauli_Z(c);

        idx_a_in_paulis_1 = 0;
        idx_b_in_paulis_1 = n_paulis_1 - 2;
    }

    // paulis_to_add_2 = Pa Za+1 ... Zb-1 Pb (b-a+1 paulis)
    size_t n_paulis_2 = b - a + 1;
    std::vector<single_pauli_type> paulis_to_add_2(n_paulis_2);
    size_t idx_in_paulis = 1;
    for(index_type i = a + 1; i < b; i++) {
        paulis_to_add_2[idx_in_paulis++] = to_pauli_Z(i);
    }
    size_t idx_a_in_paulis_2 = 0;
    size_t idx_b_in_paulis_2 = n_paulis_2 - 1;

    float_type coeffs[4] = {
        get_real(coefficient),
        get_real(coefficient),
        get_imag(coefficient),
        -get_imag(coefficient)
    };

    for(size_t i = 0; i < 4; i++) {
        if(std::abs(coeffs[i]) < eq_tolerance) {
            continue;
        }
        paulis_to_add_1[idx_a_in_paulis_1] = to_pauli(a, XX_YY_YX_XY[i].first);
        paulis_to_add_1[idx_b_in_paulis_1] = to_pauli(b, XX_YY_YX_XY[i].second);
        terms.add_term(paulis_to_add_1, -coeffs[i]);

        // paulis_to_add_2 = Pa Za+1 ... Zb-1 Pb (b-a+1 paulis)
        paulis_to_add_2[idx_a_in_paulis_2] = to_pauli(a, XX_YY_YX_XY[i].first);
        paulis_to_add_2[idx_b_in_paulis_2] = to_pauli(b, XX_YY_YX_XY[i].second);
        terms.add_term(paulis_to_add_2, coeffs[i]);
    }

}

// This is used in `jordan_wigner_two_body_4_cites`.
enum class CoeffAction {
    PosReal, PosImag, NegReal, NegImag
};

using pauli_ids_and_action = std::pair<std::array<pauli_id_type, 4>, CoeffAction>;

// This is used in `jordan_wigner_two_body_4_cites`.
constexpr std::array<pauli_ids_and_action, 16>
coeff_action_patterns_h_pqrs = {
    pauli_ids_and_action{{PauliY, PauliX, PauliY, PauliX}, CoeffAction::NegReal},
    pauli_ids_and_action{{PauliY, PauliX, PauliY, PauliY}, CoeffAction::PosImag},
    pauli_ids_and_action{{PauliY, PauliX, PauliX, PauliX}, CoeffAction::NegImag},
    pauli_ids_and_action{{PauliY, PauliX, PauliX, PauliY}, CoeffAction::NegReal},
    pauli_ids_and_action{{PauliY, PauliY, PauliY, PauliX}, CoeffAction::NegImag},
    pauli_ids_and_action{{PauliY, PauliY, PauliY, PauliY}, CoeffAction::NegReal},
    pauli_ids_and_action{{PauliY, PauliY, PauliX, PauliX}, CoeffAction::PosReal},
    pauli_ids_and_action{{PauliY, PauliY, PauliX, PauliY}, CoeffAction::NegImag},
    pauli_ids_and_action{{PauliX, PauliX, PauliY, PauliX}, CoeffAction::PosImag},
    pauli_ids_and_action{{PauliX, PauliX, PauliY, PauliY}, CoeffAction::PosReal},
    pauli_ids_and_action{{PauliX, PauliX, PauliX, PauliX}, CoeffAction::NegReal},
    pauli_ids_and_action{{PauliX, PauliX, PauliX, PauliY}, CoeffAction::PosImag},
    pauli_ids_and_action{{PauliX, PauliY, PauliY, PauliX}, CoeffAction::NegReal},
    pauli_ids_and_action{{PauliX, PauliY, PauliY, PauliY}, CoeffAction::PosImag},
    pauli_ids_and_action{{PauliX, PauliY, PauliX, PauliX}, CoeffAction::NegImag},
    pauli_ids_and_action{{PauliX, PauliY, PauliX, PauliY}, CoeffAction::NegReal}
};

// This is used in `jordan_wigner_two_body_4_cites`.
template<typename Coeff>
float_type get_coeff_after_action(Coeff coeff, CoeffAction action) noexcept {
    switch (action)
    {
    case CoeffAction::PosReal:
        return get_real(coeff);
    case CoeffAction::PosImag:
        return get_imag(coeff);
    case CoeffAction::NegReal:
        return -get_real(coeff);
    case CoeffAction::NegImag:
        return -get_imag(coeff);
    default:
        break;
    }

    return 0.0; // should NOT reach here
}

/**
 * Assumes `(p,q,r,s)` is generated by the C++ version of the Python generator
 * `itertools.combinations(itertools.combinations(range(n_qubits), 2)`,
 * where `n_qubits` is the number of qubits.
 * Also, we assume `p`, `q`, `r` and `s` are different from each other.
 * So in this function we can assume that
 *  - `p < q`
 *  - `p < r < s`
 */
template<typename Coeff>
void jordan_wigner_two_body_4_cites (
    index_type p, index_type q, index_type r, index_type s,
    Coeff coefficient, HermitianPauliTerms& terms
) {
    if(std::abs(coefficient) < eq_tolerance) {
        return;
    }

    std::array<index_type, 4> pqrs{p, q, r, s};
    std::array<pauli_id_type, 4> idx_four_pauli_ids{0, 1, 2, 3};

    std::sort(
        idx_four_pauli_ids.begin(),
        idx_four_pauli_ids.end(),
        [pqrs](pauli_id_type a, pauli_id_type b) -> bool {
            return pqrs[a] < pqrs[b];
        }
    );

    std::sort(pqrs.begin(), pqrs.end());
    p = pqrs[0]; q = pqrs[1]; r = pqrs[2]; s = pqrs[3];
    // now p < q < r < s

    size_t num_paulis_to_add = q - p + s - r + 2;
    std::vector<single_pauli_type> paulis(num_paulis_to_add);

    size_t idx_in_paulis = 1;
    for(index_type i = p + 1; i < q; i++) {
        paulis[idx_in_paulis++] = to_pauli_Z(i);
    }
    idx_in_paulis += 2;
    for(index_type i = r + 1; i < s; i++) {
        paulis[idx_in_paulis++] = to_pauli_Z(i);
    }

    for(size_t i = 0; i < coeff_action_patterns_h_pqrs.size(); i++) {
        std::array<pauli_id_type, 4> 
        four_pauli_ids = coeff_action_patterns_h_pqrs[i].first;
        
        CoeffAction action = coeff_action_patterns_h_pqrs[i].second;

        float_type coeff = 0.125 * get_coeff_after_action(coefficient, action);

        if(std::abs(coeff) < eq_tolerance) {
            continue;
        }

        paulis[0] = to_pauli(p, four_pauli_ids[idx_four_pauli_ids[0]]);
        paulis[q - p] = to_pauli(q, four_pauli_ids[idx_four_pauli_ids[1]]);
        paulis[q - p + 1] = to_pauli(r, four_pauli_ids[idx_four_pauli_ids[2]]);
        paulis[num_paulis_to_add - 1] = to_pauli(s, four_pauli_ids[idx_four_pauli_ids[3]]);
        terms.add_term(paulis, coeff);
    }
}

/**
 * Get flat index for h_{pqrs} from `p`, `q`, `r` and `s`.
 * This function returns `n_qubits**3 * p + n_qubits**2 * q + n_qubits * r + s`
 */
inline size_t get_flat_index (
    index_type p, index_type q, index_type r, index_type s,
    index_type n_qubits
) noexcept {
    size_t _n_qubits = static_cast<size_t>(n_qubits);
    return _n_qubits * _n_qubits * _n_qubits * p
            + _n_qubits * _n_qubits * q
            + _n_qubits * r
            + s;
}

/**
 * Theoretically, this function returns a value
 * that is equivalent to `h_{pqrs} - h_{pqsr} - h_{qprs} + h_{qpsr}`,
 * where `two_body` represents `h_{pqrs}`.
 */
template<typename Coeff>
Coeff get_two_body_coeffs_sum(
    const Coeff* const two_body,
    index_type p, index_type q, index_type r, index_type s,
    index_type n_qubits
) {
    return 0.5 * (
        two_body[get_flat_index(p, q, r, s, n_qubits)]
        + get_conj(two_body[get_flat_index(s, r, q, p, n_qubits)])
        - two_body[get_flat_index(p, q, s, r, n_qubits)]
        - get_conj(two_body[get_flat_index(r, s, q, p, n_qubits)])
        - two_body[get_flat_index(q, p, r, s, n_qubits)]
        - get_conj(two_body[get_flat_index(s, r, p, q, n_qubits)])
        + two_body[get_flat_index(q, p, s, r, n_qubits)]
        + get_conj(two_body[get_flat_index(r, s, p, q, n_qubits)])   
    );
}

} // namespace helper_internal

/**
 * Returns the qubit index of `pauli` by removing its two most significant bits.
 * This is done by masking `pauli` with `index_mask(=0b0011....11)`.
 */
inline index_type get_index(single_pauli_type pauli) noexcept {
    return pauli & helper_internal::index_mask;
}

// Returns the pauli id that is embedded in the two most significant bits in `pauli`.
inline pauli_id_type get_pauli_id(single_pauli_type pauli) noexcept {
    return static_cast<pauli_id_type>(pauli >> (sizeof(single_pauli_type) * 8 - 2));
}

/**
 * Jordan Wigner transformation for second quantized Hamiltonian
 * constant + sum_{p, q} h_{p, q} a^dagger_p a_q + sum_{p, q, r, s} h_{p, q, r, s} a^dagger_p a^dagger_q a_r a_s.
 * @param[in] one_body: n_qubits x n_qubits array (real or complex) representing `h_{pq}`.
 * @param[in] two_body: n_qubits x n_qubits x n_qubits x n_qubits array (real or complex) representing `h_{pqrs}`
 * @param[in] constant: constant number in the second quantized Hamiltonian.
 * @param[in] n_qubits: number of qubits of the second quantized Hamiltonian.
 * @return `std::unique_ptr<HermitianPauliTerms>`: pauli terms after Jordan Wigner transformation.
 */
template<typename Coeff>
std::unique_ptr<HermitianPauliTerms> jordan_wigner_from_electron_intergrals(
    const Coeff* const one_body, const Coeff* const two_body,
    float_type constant, index_type n_qubits
) {
    static_assert(
        std::is_same<Coeff, float_type>::value == true ||
        std::is_same<Coeff, std::complex<float_type>>::value == true,
        "`one_body` and `two_body` must be either \
        real or complex double tensor."
    );

    constexpr index_type
    max_n_qubits_allowed = std::numeric_limits<index_type>::max() >> 2;

    if(n_qubits > max_n_qubits_allowed) {
        std::stringstream ss;
        ss << "At line " << __LINE__ << " in " << __FILE__ << ": "
            << "`n_qubits` must be less than " << max_n_qubits_allowed + 1 << ". "
            << "But got " << n_qubits << ".";
        throw std::out_of_range(ss.str());
    }

    std::unique_ptr<HermitianPauliTerms>
    pauli_terms = std::make_unique<HermitianPauliTerms>();
    
    pauli_terms->add_constant(constant);

    index_type p, q, r, s;
    Coeff coefficient;

    for(p = 0; p < n_qubits; p++) {
        coefficient = one_body[p * n_qubits + p];
        helper_internal::jordan_wigner_one_body(
            p, p, helper_internal::get_real(coefficient), *pauli_terms
        );
    }

    for(p = 0; p < n_qubits; p++) {
        for(q = p + 1; q < n_qubits; q++) {
            coefficient = 0.5 * (
                one_body[p * n_qubits + q] + helper_internal::get_conj(one_body[q * n_qubits + p])
            );
            helper_internal::jordan_wigner_one_body(p, q, coefficient, *pauli_terms);

            coefficient = two_body[helper_internal::get_flat_index(p, q, p, q, n_qubits)]
                        - two_body[helper_internal::get_flat_index(p, q, q, p, n_qubits)]
                        - two_body[helper_internal::get_flat_index(q, p, p, q, n_qubits)]
                        + two_body[helper_internal::get_flat_index(q, p, q, p, n_qubits)];
            helper_internal::jordan_wigner_two_body_2_cites(p, q, coefficient, *pauli_terms);
        }
    }

    // These four for-loops and a if statement work as a C++ version of Python's generator
    // itertools.combinations(itertools.combinations(range(n_qubits), 2)`.
    for(p = 0; p < n_qubits; p++) {
        for(q = p + 1; q < n_qubits; q++) {
            for(r = p; r < n_qubits; r++) {
                for(s = r + 1; s < n_qubits; s++) {
                    if((n_qubits * p + q ) < (n_qubits * r + s)) {
                        coefficient = helper_internal::get_two_body_coeffs_sum(
                            two_body, p, q, r, s, n_qubits
                        );
                        
                        if(p == r || q == r || q == s) [[unlikely]] {
                            helper_internal::jordan_wigner_two_body_3_cites(
                                p, q, r, s, coefficient, *pauli_terms
                            );
                        } else [[likely]] {
                            helper_internal::jordan_wigner_two_body_4_cites(
                                p, q, r, s, coefficient, *pauli_terms
                            );
                        }
                    }
                }
            }
        }
    }

    return pauli_terms;
}


} // namespace observable_helper
